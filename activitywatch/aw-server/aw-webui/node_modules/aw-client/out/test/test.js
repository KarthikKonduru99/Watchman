"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const aw_client_1 = require("../aw-client");
function isAxiosError(error) {
    return error.isAxiosError;
}
// Bucket info
const bucketId = "aw-client-js-test";
const eventType = "test";
const hostname = "unknown";
const clientName = "aw-client-js-unittest";
const testevent = {
    timestamp: new Date(),
    duration: 0,
    data: {
        label: "this is a test label",
    },
};
describe("Basic API usage", () => {
    // Create client
    const awc = new aw_client_1.AWClient(clientName, {
        testing: true,
    });
    before("Delete test bucket", () => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        // Delete bucket if it exists
        try {
            return yield awc.deleteBucket(bucketId);
        }
        catch (err) {
            if (isAxiosError(err)) {
                if (((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {
                    return;
                }
            }
            throw err;
        }
    }));
    // Make sure the test bucket exists before each test case
    beforeEach("Create test bucket", () => {
        return awc.ensureBucket(bucketId, eventType, hostname);
    });
    it("info", () => __awaiter(void 0, void 0, void 0, function* () {
        const resp = yield awc.getInfo();
        assert.equal(resp.testing, true);
    }));
    // NOTE: This test will fail in CI until v0.12 is released (with support for 'get event by ID')
    it("Post event, get event and assert", () => __awaiter(void 0, void 0, void 0, function* () {
        yield awc.insertEvent(bucketId, testevent);
        const events = yield awc.getEvents(bucketId, { limit: 1 });
        assert.equal(events.length, 1);
        let event = events[0];
        event = yield awc.getEvent(bucketId, event.id);
        assert.equal(testevent.timestamp.toISOString(), event.timestamp.toISOString());
        assert.equal(testevent.data.label, event.data.label);
    }));
    it("Create, delete and get buckets", () => __awaiter(void 0, void 0, void 0, function* () {
        /* Create -> getBucketInfo and verify -> delete -> getBuckets and verify */
        yield awc.ensureBucket(bucketId, eventType, hostname);
        let buckets = yield awc.getBuckets();
        //console.log("getBuckets", buckets);
        assert.equal(true, bucketId in buckets);
        const bucketInfo = yield awc.getBucketInfo(bucketId);
        //console.log("getBucketInfo", bucketInfo);
        assert.equal(bucketInfo.created instanceof Date, true);
        assert.equal(clientName, bucketInfo.client);
        yield awc.deleteBucket(bucketId);
        buckets = yield awc.getBuckets();
        //console.log("getBuckets", buckets);
        assert.equal(false, bucketId in buckets);
    }));
    it("Heartbeat", () => __awaiter(void 0, void 0, void 0, function* () {
        // Send 10 heartbeat events with little time difference one after another (for testing the queue)
        yield Promise.all(Array.from({ length: 10 }, () => {
            const curTimestamp = new Date();
            const newEvent = {
                timestamp: curTimestamp,
                duration: testevent.duration,
                data: testevent.data,
            };
            return awc.heartbeat(bucketId, 5, newEvent);
        }));
        const events = yield awc.getEvents(bucketId);
        assert.equal(events.length, 1);
    }));
    it("Query", () => __awaiter(void 0, void 0, void 0, function* () {
        const e1 = Object.assign(Object.assign({}, testevent), { timestamp: new Date("2022-01-01") });
        const e2 = Object.assign(Object.assign({}, testevent), { timestamp: new Date("2022-01-02") });
        yield awc.heartbeat(bucketId, 5, e1);
        yield awc.heartbeat(bucketId, 5, e2);
        // Both these are valid timeperiod specs
        const timeperiods = [
            { start: e1.timestamp, end: e2.timestamp },
            `${e1.timestamp.toISOString()}/${e2.timestamp.toISOString()}`,
        ];
        const query = [`bucket="${bucketId}";`, "RETURN=query_bucket(bucket);"];
        const resp = yield awc.query(timeperiods, query);
        const resp_e1 = resp[0][0];
        const resp_e2 = resp[0][1];
        assert.equal(e1.timestamp.toISOString(), new Date(resp_e2.timestamp).toISOString());
        assert.equal(e1.data.label, resp_e2.data.label);
        assert.equal(e2.timestamp.toISOString(), new Date(resp_e1.timestamp).toISOString());
        assert.equal(e2.data.label, resp[0][0].data.label);
    }));
});
describe("API config behavior", () => {
    it("can abort requests", () => {
        const awc = new aw_client_1.AWClient(clientName, {
            testing: true,
        });
        const caught = new Promise((resolve, reject) => {
            awc.getInfo().catch(resolve).then(reject);
        });
        awc.abort();
        return caught;
    });
});
//# sourceMappingURL=test.js.map