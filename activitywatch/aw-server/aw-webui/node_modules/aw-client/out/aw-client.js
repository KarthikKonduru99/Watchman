"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AWClient = void 0;
const axios_1 = require("axios");
class AWClient {
    constructor(clientname, options = {}) {
        this.heartbeatQueues = {};
        this.clientname = clientname;
        this.testing = options.testing || false;
        if (typeof options.baseURL === "undefined") {
            const port = !options.testing ? 5600 : 5666;
            // Note: had to switch to 127.0.0.1 over localhost as otherwise there's
            // a possibility it tries to connect to IPv6's `::1`, which will be refused.
            this.baseURL = `http://127.0.0.1:${port}`;
        }
        else {
            this.baseURL = options.baseURL;
        }
        this.controller = options.controller || new AbortController();
        this.req = axios_1.default.create({
            baseURL: this.baseURL + "/api",
            timeout: options.timeout || 30000,
        });
    }
    _get(endpoint, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.req
                .get(endpoint, Object.assign(Object.assign({}, params), { signal: this.controller.signal }))
                .then((res) => (res && res.data) || res);
        });
    }
    _post(endpoint, data = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.req
                .post(endpoint, data, { signal: this.controller.signal })
                .then((res) => (res && res.data) || res);
        });
    }
    _delete(endpoint) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.req.delete(endpoint, { signal: this.controller.signal });
        });
    }
    getInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._get("/0/info");
        });
    }
    abort(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            console.info(msg || "Requests cancelled");
            this.controller.abort();
            this.controller = new AbortController();
        });
    }
    ensureBucket(bucketId, type, hostname) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._post(`/0/buckets/${bucketId}`, {
                    client: this.clientname,
                    type,
                    hostname,
                });
            }
            catch (err) {
                // Will return 304 if bucket already exists
                if (axios_1.default.isAxiosError(err) &&
                    err.response &&
                    err.response.status === 304) {
                    return { alreadyExist: true };
                }
                throw err;
            }
            return { alreadyExist: false };
        });
    }
    createBucket(bucketId, type, hostname) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._post(`/0/buckets/${bucketId}`, {
                client: this.clientname,
                type,
                hostname,
            });
            return undefined;
        });
    }
    deleteBucket(bucketId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._delete(`/0/buckets/${bucketId}?force=1`);
            return undefined;
        });
    }
    getBuckets() {
        return __awaiter(this, void 0, void 0, function* () {
            const buckets = yield this._get("/0/buckets/");
            Object.keys(buckets).forEach((bucket) => {
                buckets[bucket].created = new Date(buckets[bucket].created);
                if (buckets[bucket].last_updated) {
                    buckets[bucket].last_updated = new Date(buckets[bucket].last_updated);
                }
            });
            return buckets;
        });
    }
    getBucketInfo(bucketId) {
        return __awaiter(this, void 0, void 0, function* () {
            const bucket = yield this._get(`/0/buckets/${bucketId}`);
            bucket.created = new Date(bucket.created);
            return bucket;
        });
    }
    getEvent(bucketId, eventId) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get a single event by ID
            const event = yield this._get("/0/buckets/" + bucketId + "/events/" + eventId);
            event.timestamp = new Date(event.timestamp);
            return event;
        });
    }
    getEvents(bucketId, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const events = yield this._get("/0/buckets/" + bucketId + "/events", {
                params,
            });
            events.forEach((event) => {
                event.timestamp = new Date(event.timestamp);
            });
            return events;
        });
    }
    countEvents(bucketId, startTime, endTime) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {
                starttime: startTime ? startTime.toISOString() : null,
                endtime: endTime ? endTime.toISOString() : null,
            };
            return this._get("/0/buckets/" + bucketId + "/events/count", {
                params,
            });
        });
    }
    insertEvent(bucketId, event) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.insertEvents(bucketId, [event]);
        });
    }
    insertEvents(bucketId, events) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._post("/0/buckets/" + bucketId + "/events", events);
        });
    }
    // Just an alias for insertEvent requiring the event to have an ID assigned
    replaceEvent(bucketId, event) {
        return __awaiter(this, void 0, void 0, function* () {
            if (event.id === undefined) {
                throw Error("Can't replace event without ID assigned");
            }
            yield this.insertEvent(bucketId, event);
        });
    }
    deleteEvent(bucketId, eventId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._delete("/0/buckets/" + bucketId + "/events/" + eventId);
        });
    }
    /**
     *
     * @param bucketId The id of the bucket to send the heartbeat to
     * @param pulsetime The maximum amount of time in seconds since the last heartbeat to be merged
     *                  with the previous heartbeat in aw-server
     * @param heartbeat The actual heartbeat event
     */
    heartbeat(bucketId, pulsetime, heartbeat) {
        // Create heartbeat queue for bucket if not already existing
        if (!Object.prototype.hasOwnProperty.call(this.heartbeatQueues, bucketId)) {
            this.heartbeatQueues[bucketId] = {
                isProcessing: false,
                data: [],
            };
        }
        return new Promise((resolve, reject) => {
            // Add heartbeat request to queue
            this.heartbeatQueues[bucketId].data.push({
                onSuccess: resolve,
                onError: reject,
                pulsetime,
                heartbeat,
            });
            this.updateHeartbeatQueue(bucketId);
        });
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    query(timeperiods, query) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = {
                query,
                timeperiods: timeperiods.map((tp) => {
                    return typeof tp !== "string"
                        ? `${tp.start.toISOString()}/${tp.end.toISOString()}`
                        : tp;
                }),
            };
            return yield this._post("/0/query/", data);
        });
    }
    /* eslint-enable @typescript-eslint/no-explicit-any */
    send_heartbeat(bucketId, pulsetime, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = "/0/buckets/" + bucketId + "/heartbeat?pulsetime=" + pulsetime;
            const heartbeat = yield this._post(url, data);
            heartbeat.timestamp = new Date(heartbeat.timestamp);
            return heartbeat;
        });
    }
    // Start heartbeat queue processing if not currently processing
    updateHeartbeatQueue(bucketId) {
        const queue = this.heartbeatQueues[bucketId];
        if (!queue.isProcessing && queue.data.length) {
            const { pulsetime, heartbeat, onSuccess, onError } = queue.data.shift();
            queue.isProcessing = true;
            this.send_heartbeat(bucketId, pulsetime, heartbeat)
                .then(() => {
                onSuccess();
                queue.isProcessing = false;
                this.updateHeartbeatQueue(bucketId);
            })
                .catch((err) => {
                onError(err);
                queue.isProcessing = false;
                this.updateHeartbeatQueue(bucketId);
            });
        }
    }
}
exports.AWClient = AWClient;
//# sourceMappingURL=aw-client.js.map